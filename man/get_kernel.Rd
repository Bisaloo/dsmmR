% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/generic_functions.R
\name{get_kernel}
\alias{get_kernel}
\title{Obtain the Drifting Semi-Markov Kernel}
\usage{
get_kernel(obj, t, u, v, l, klim = 80L)
}
\arguments{
\item{obj}{An object of S3 class \code{`dsmm`, `dsmm_fit`,
`dsmm_nonparametric`} or \code{`dsmm_parametric`}.}

\item{t}{Optional, but recommended. Positive integer specifying a
single point \eqn{t} in the length of the model.}

\item{u}{Optional. Character specifying the previous state \eqn{u}.
It can also be given as a positive integer, describing the order it appears
in the state space.}

\item{v}{Optional. Character specifying the next state \eqn{v}.
It can also be given as a positive integer, describing the order it appears
in the state space.}

\item{l}{Optional. Positive integer specifying the sojourn time \eqn{l}
that is spent in the previous state \eqn{u}.}

\item{klim}{Optional. Positive integer.
Used only for the S3 class \code{dsmm_parametric}.
Specifies the time horizon used to approximate the \eqn{d + 1}
(or 1, if \eqn{f} is \emph{not drifting}) sojourn time distributions.
Default value is 80L. A larger value will result in a considerably larger
kernel (which has dimensions of \eqn{(s, s, klim, n + 1)}), that will
require more memory and will slow down considerably the
\code{`simulate.dsmm()`} method.
(\link{dsmm_parametric}, \link{simulate.dsmm})}
}
\value{
An array with dimensions of \eqn{(n+1, s, s, k_{max})}, giving the
value of \eqn{q_{\frac{t}{n}}(u,v,l)} for the corresponding \eqn{(t,u,v,l)}.
If any of \eqn{t,u,v,} or \eqn{l} were specified, their dimension in the
array becomes 1.
}
\description{
This is a generic method that computes and returns the Drifting
Semi-Markov Kernel as a numerical array of dimensions (s, s, k_max, n + 1).
}
\details{
The Drifting Semi-Markov Kernel \eqn{q_{\frac{t}{n}}(u,v,l)} describes
the probability to jump to the current state \eqn{v} when the previous
state \eqn{u} had a sojourn time of \eqn{l}, for every point \eqn{t} of a
model with length \eqn{n}.
Specifically, it is given as the sum of a linear combination:
\deqn{q_{\frac{t}{n}}(u,v,l)=
     \sum_{i = 0}^{d}A_{i}(t)q_{\frac{i}{d}}(u,v,l),}
where \eqn{A_i, i = 0, \dots, d} are \eqn{d + 1} polynomials with degree
\eqn{d} that satisfy certain conditions (\link{dsmmR}) and
\eqn{q_{\frac{i}{d}}(u,v,l), i = 0, \dots, d}
are \eqn{d + 1} kernels that describe a multiplication between
a number of Markov Transition Matrices \eqn{p} and
a number of Sojourn Time Distributions \eqn{f}.
Three possible model specifications are described below.

\strong{Model 1}

In this case, both \eqn{p} and \eqn{f} are "drifting" between \eqn{d + 1}
fixed points of the model, hence the "drifting" in
Drifting Semi-Markov Models. Therefore,
\deqn{q_{\frac{i}{d}}(u,v,l)=
     {p_{\frac{i}{d}}(u,v)}{f_{\frac{i}{d}}(u,v,l)},}
where for \eqn{i = 0, \dots, d} we have \eqn{d + 1} Markov
Transition Matrices \eqn{p_{\frac{i}{d}}(u,v,l)},
and \eqn{d + 1} Sojourn Time Distributions
\eqn{f_{\frac{i}{d}}(u,v,l)}, where \eqn{d} is the polynomial degree.

\strong{Model 2}

In this case, \eqn{p} is drifting and \eqn{f} \strong{is not drifting}.
Therefore,
\deqn{q_{\frac{i}{d}}(u,v,l)={p_{\frac{i}{d}}(u,v)}{f(u,v,l)},}
where the \eqn{f(u,v,l)} is constant, not drifting alongside the point
\eqn{t} of the model with length \eqn{n}.


\strong{Model 3}

In this case, \eqn{f} is drifting and \eqn{p} \strong{is not drifting}.
Therefore, the Markov Kernel is now described as:
\deqn{q_{\frac{i}{d}}(u,v,l)={p(u,v)}{f_{\frac{i}{d}}(u,v,l)},}
where \eqn{p(u,v)} is constant, not drifting alongside the point
\eqn{t} of the model with length \eqn{n}.
}
\examples{
# Setup.
states <- c("Rouen", "Bucharest", "Samos", "Aigio", "Marseille")
seq <- create_sequence(states, probs = c(0.3, 0.1, 0.1, 0.3, 0.2))
obj_model_2 <- fit_dsmm(
    sequence = seq,
    states = states,
    degree = 3,
    f_is_drifting = FALSE,
    p_is_drifting = TRUE
)

# Get the kernel.
kernel_model_2 <- get_kernel(obj_model_2)
cat(paste0(
    "If no further arguments are made, kernel has dimensions for all ",
    "u, v, l, t:\n",
    "(s, s, k_max, n + 1) = (",
    paste(dim(kernel_model_2), collapse = ", "), ")"
))

# Specifying `t`.
kernel_model_2_t <- get_kernel(obj_model_2, t = 100)
# kernel_model_2[,,,t=100]
cat(paste0(
    "If we specify t, the kernel has dimensions for all the remaining ",
    "u, v, l:\n(s, s, k_max) = (",
    paste(dim(kernel_model_2_t), collapse = ", "), ")"
))

# Specifying `t` and `u`.
kernel_model_2_tu <- get_kernel(obj_model_2, t = 2, u = "Aigio")
# kernel_model_2["Aigio",,,t=100]
cat(paste0(
    "If we specify t and u, the kernel has dimensions for all the ",
    " remaining v, l:\n(s, k_max) = (",
    paste(dim(kernel_model_2_tu), collapse = ", "), ")"
))


# Specifying `t`, `u` and `v`.
kernel_model_2_tuv <- get_kernel(obj_model_2, t = 3,
                                 u = "Rouen", v = "Bucharest")
# kernel_model_2["Aigio","Bucharest",,t=100]
cat(paste0(
    "If we specify t, u and v, the kernel has dimensions for all l:\n",
    "(k_max) = (", paste(length(kernel_model_2_tuv), collapse = ", "), ")"
))

# It is possible to ask for any valid combination of `u`, `v`, `l` and `t`.
}
\seealso{
More theory: \link{dsmmR}, \link{dsmm_fit},
\link{dsmm_parametric}, \link{dsmm_nonparametric}

Sequence simulation: \link{simulate.dsmm}, \link{create_sequence}
}
